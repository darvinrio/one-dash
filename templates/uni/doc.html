{% extends 'base.html' %}

{% block head %}
<link rel="stylesheet" href="{{url_for('static',filename='css/prism.css')}}">
<script src="{{url_for('static',filename='js/prism.js')}}"></script>
{% endblock %}

{% block body %}

<section class="container">
  <h3 class="display">Queries</h3>
 
  <div class="accordion" id="accordionExample">
    <div class="accordion-item">
      <h2 class="accordion-header" id="headingOne">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapseOne"
          aria-expanded="true"
          aria-controls="collapseOne"
        >
          Uniswap Top 10 Pool stats
        </button>
      </h2>
      <div
        id="collapseOne"
        class="accordion-collapse collapse"
        aria-labelledby="headingOne"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
  with top5 as(
  SELECT 
    st.block_timestamp as date,
  st.pool_name,
  (st.token0_balance_usd + st.token1_balance_usd) as total_bal,
  st.pool_address
  FROM uniswapv3.pool_stats st
    
  INNER JOIN (
    SELECT MAX(p1.block_timestamp) as maxDate, p1.pool_address
    FROM uniswapv3.pool_stats p1
    GROUP BY p1.pool_address
  ) p2 ON st.pool_address = p2.pool_address AND st.block_timestamp= p2.maxDate
  
  WHERE total_bal IS NOT NULL
  
  ORDER BY total_bal DESC 
  
  LIMIT 10
),
top10_details as(
  SELECT 
    date(st.block_timestamp) as date,
    st.pool_name,
    (st.token0_balance_usd + st.token1_balance_usd) as total_bal,
    st.pool_address,
  	price_0_1,
	price_1_0,
  	token0_symbol,
  	token0_balance_adjusted,
  	token0_balance_usd,
  	token1_symbol,
  	token1_balance_adjusted,
  	token1_balance_usd
  FROM uniswapv3.pool_stats st
    
  INNER JOIN (
    SELECT MAX(p1.block_timestamp) as maxDate, p1.pool_address
    FROM uniswapv3.pool_stats p1
    GROUP BY p1.pool_address,date(p1.block_timestamp)
  ) p2 ON st.pool_address = p2.pool_address AND st.block_timestamp= p2.maxDate
  
  WHERE total_bal IS NOT NULL
    and st.pool_address in (select pool_address from top5)
  
  ORDER BY date DESC   
)


select * from top10_details
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="headingTwo">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapseTwo"
          aria-expanded="false"
          aria-controls="collapseTwo"
        >
          Uniswap Fees
        </button>
      </h2>
      <div
        id="collapseTwo"
        class="accordion-collapse collapse"
        aria-labelledby="headingTwo"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
SELECT 
  TRUNC(s.block_timestamp, 'day') as date,
  p.fee_percent,
  SUM((ABS(amount0_usd) + ABS(amount1_usd))/2) * p.fee_percent / 100 as fees_collected
FROM uniswapv3.swaps s
JOIN uniswapv3.pools p
ON s.pool_address = p.pool_address
GROUP BY 1,2
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="headingThree">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapseThree"
          aria-expanded="false"
          aria-controls="collapseThree"
        >
          Uniswap Fees for Pools with TVL < $ 10M
        </button>
      </h2>
      <div
        id="collapseThree"
        class="accordion-collapse collapse"
        aria-labelledby="headingThree"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH date_tvl as (
SELECT 
  balance_date,
  user_address as pool_address,
  fee_percent,
  SUM(NVL(amount_usd, 0)) as TVL
FROM ethereum.erc20_balances a
JOIN uniswapv3.pools b
ON b.pool_address = a.user_address
WHERE (amount_usd / balance) < 1000000 AND balance <> 0 AND balance IS NOT NULL
GROUP BY 1,2,3
)


SELECT
  date,
  fee_percent,
  MEDIAN(apr) as med_apr
FROM (
SELECT 
  TRUNC(s.block_timestamp, 'day') as date,
  p.pool_address,
  p.pool_name,
  p.fee_percent,
  SUM(((ABS(amount0_usd) + ABS(amount1_usd))/2) / tvl) * p.fee_percent * 365 as apr
FROM uniswapv3.swaps s
JOIN uniswapv3.pools p
ON s.pool_address = p.pool_address
JOIN date_tvl b
ON TRUNC(s.block_timestamp, 'day') = b.balance_date AND p.pool_address = b.pool_address
WHERE tvl <> 0 AND tvl IS NOT NULL AND tvl > 100000 AND tvl <= 10000000
GROUP BY 1,2,3,4
)
GROUP BY 1,2
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading4">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse4"
          aria-expanded="false"
          aria-controls="collapse4"
        >
          Uniswap Fees for Pools with TVL > $ 10M
        </button>
      </h2>
      <div
        id="collapse4"
        class="accordion-collapse collapse"
        aria-labelledby="heading4"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH date_tvl as (
SELECT 
  balance_date,
  user_address as pool_address,
  fee_percent,
  SUM(NVL(amount_usd, 0)) as TVL
FROM ethereum.erc20_balances a
JOIN uniswapv3.pools b
ON b.pool_address = a.user_address
WHERE (amount_usd / balance) < 1000000 AND balance <> 0 AND balance IS NOT NULL
GROUP BY 1,2,3
)


SELECT
  date,
  fee_percent,
  MEDIAN(apr) as med_apr
FROM (
SELECT 
  TRUNC(s.block_timestamp, 'day') as date,
  p.pool_address,
  p.pool_name,
  p.fee_percent,
  SUM(((ABS(amount0_usd) + ABS(amount1_usd))/2) / tvl) * p.fee_percent * 365 as apr
FROM uniswapv3.swaps s
JOIN uniswapv3.pools p
ON s.pool_address = p.pool_address
JOIN date_tvl b
ON TRUNC(s.block_timestamp, 'day') = b.balance_date AND p.pool_address = b.pool_address
WHERE tvl <> 0 AND tvl IS NOT NULL AND tvl > 10000000
GROUP BY 1,2,3,4
)
GROUP BY 1,2
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading5">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse5"
          aria-expanded="false"
          aria-controls="collapse5"
        >
          Uniswap LP volatility
        </button>
      </h2>
      <div
        id="collapse5"
        class="accordion-collapse collapse"
        aria-labelledby="heading5"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH top10_lp AS (
SELECT 
    liquidity_provider,
    COUNT(block_id) as n_tx
FROM 
  uniswapv3.positions
WHERE
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' -- USDC-WETH v3
GROUP BY
    liquidity_provider
ORDER BY
  n_tx DESC
LIMIT 10
),
  
lp_with_active_positions AS (
  --find active pools that already exist before 30 days ago
SELECT
    liquidity_provider,
    COUNT(DISTINCT nf_token_id) as n_active_positions
FROM
  uniswapv3.positions
WHERE
  liquidity_provider IN (SELECT liquidity_provider FROM top10_lp) AND
  is_active = TRUE AND
    -- block_timestamp < CURRENT_DATE - 30 AND
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
GROUP BY
  liquidity_provider
),

lp_with_active_positions_current AS (
SELECT
    liquidity_provider,
    COUNT(DISTINCT nf_token_id) as n_active_positions
FROM
  uniswapv3.positions
WHERE
  liquidity_provider IN (SELECT liquidity_provider FROM top10_lp) AND
  is_active = TRUE AND
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
GROUP BY
  liquidity_provider
),

weth_price AS (
SELECT 
    TRUNC(hour, 'day') AS date,
    AVG(price) AS avg_price,
    MAX(price) AS max_price,
    MIN(price) AS min_price
FROM ethereum.token_prices_hourly
WHERE 
  symbol = 'WETH' --AND
  -- hour >= CURRENT_DATE --- 30
GROUP BY
  date
),

avg_prices AS (
  
SELECT
    TRUNC(block_timestamp, 'day') AS date,
    AVG(tick_upper) AS avg_tick_upper,
    AVG(tick_lower) AS avg_tick_lower,
    AVG(price_lower_0_1_usd) AS avg_eth_lower_usd,
    AVG(price_upper_0_1_usd) AS avg_eth_higher_usd
FROM
  uniswapv3.positions p
WHERE
  liquidity_provider IN (SELECT liquidity_provider FROM lp_with_active_positions_current) AND
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' --AND -- USDC-WETH v3
    -- block_timestamp >= CURRENT_DATE - 30
GROUP BY
  date
)

SELECT
  a.date,
  a.avg_tick_upper - a.avg_tick_lower AS tick_gap,
  ((a.avg_tick_upper / a.avg_tick_lower) - 1) * 100 AS pct_tick_gap,
  a.avg_eth_higher_usd - a.avg_eth_lower_usd AS range_gap,
  ((a.avg_eth_higher_usd / a.avg_eth_lower_usd) - 1) * 100 AS pct_range_gap,
    p.max_price - p.min_price AS price_gap,
    ((p.max_price - p.min_price) / p.avg_price) * 100 AS volatility
FROM
  avg_prices a
JOIN
  weth_price p
ON
  p.date = a.date
GROUP BY
  a.date,
    tick_gap,
    pct_tick_gap,
    range_gap,
    pct_range_gap,
    price_gap,
    volatility
ORDER BY
  a.date DESC
  
  
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading11">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse11"
          aria-expanded="false"
          aria-controls="collapse11"
        >
          Uniswap LP range efficiency
        </button>
      </h2>
      <div
        id="collapse11"
        class="accordion-collapse collapse"
        aria-labelledby="heading11"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH top10_lp AS (
SELECT 
    liquidity_provider,
    COUNT(block_id) as n_tx
FROM 
  uniswapv3.positions
WHERE
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' -- USDC-WETH v3
GROUP BY
    liquidity_provider
ORDER BY
  n_tx DESC
LIMIT 10
),
  
lp_with_active_positions AS (
  --find active pools that already exist before 30 days ago
SELECT
    liquidity_provider,
    COUNT(DISTINCT nf_token_id) as n_active_positions
FROM
  uniswapv3.positions
WHERE
  liquidity_provider IN (SELECT liquidity_provider FROM top10_lp) AND
  is_active = TRUE AND
    block_timestamp < CURRENT_DATE --- 30 
  AND
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
GROUP BY
  liquidity_provider
),

lp_with_active_positions_current AS (
SELECT
    liquidity_provider,
    COUNT(DISTINCT nf_token_id) as n_active_positions
FROM
  uniswapv3.positions
WHERE
  liquidity_provider IN (SELECT liquidity_provider FROM top10_lp) AND
  is_active = TRUE AND
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8'
GROUP BY
  liquidity_provider
),

weth_price AS (
SELECT 
    TRUNC(hour, 'day') AS date,
    AVG(price) AS avg_price,
    MAX(price) AS max_price,
    MIN(price) AS min_price
FROM ethereum.token_prices_hourly
WHERE 
  symbol = 'WETH' --AND
  -- hour >= CURRENT_DATE - 30
GROUP BY
  date
),

avg_prices AS (
  
SELECT
    TRUNC(block_timestamp, 'day') AS date,
    AVG(tick_upper) AS avg_tick_upper,
    AVG(tick_lower) AS avg_tick_lower,
    AVG(price_lower_0_1_usd) AS avg_eth_lower_usd,
    AVG(price_upper_0_1_usd) AS avg_eth_higher_usd
FROM
  uniswapv3.positions p
WHERE
  liquidity_provider IN (SELECT liquidity_provider FROM lp_with_active_positions_current) AND
  pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' --AND -- USDC-WETH v3
    -- block_timestamp >= CURRENT_DATE - 30
GROUP BY
  date
)

SELECT
  a.date,
    a.avg_tick_upper,
    a.avg_tick_lower,
  a.avg_eth_lower_usd,
  a.avg_eth_higher_usd,
  p.avg_price AS avg_eth_price,
  p.max_price AS max_eth_price,
  p.min_price AS min_eth_price
FROM
  avg_prices a
JOIN
  weth_price p
ON
  p.date = a.date
GROUP BY
  a.date,
    a.avg_tick_upper,
    a.avg_tick_lower,
  a.avg_eth_lower_usd,
  a.avg_eth_higher_usd,
  avg_eth_price,
  max_eth_price,
  min_eth_price
ORDER BY
  a.date DESC
  
                
  
  
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading6">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse6"
          aria-expanded="false"
          aria-controls="collapse6"
        >
        Uniswap Swap volume 
        </button>
      </h2>
      <div
        id="collapse6"
        class="accordion-collapse collapse"
        aria-labelledby="heading6"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
with uniswaps as(
  select 
    block_id,
    block_timestamp,
    tx_id,
    pool_address,
    pool_name,
    amount0_adjusted,
    token0_symbol,
    token0_price,
    amount1_adjusted,
    token1_symbol,
    token1_price,
    (abs(amount0_adjusted*token0_price)+abs(amount1_adjusted*token1_price))/2 as usd_volume
  from uniswapv3.swaps
),
dailyvol as(
  select 
    date(block_timestamp) as date, 
    sum(usd_volume) as daily_usd_volume
  from uniswaps
  group by date(block_timestamp)
)

select * from dailyvol  
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading7">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse7"
          aria-expanded="false"
          aria-controls="collapse7"
        >
          Uniswap Stable Stable pool activity *
        </button>
      </h2>
      <div
        id="collapse7"
        class="accordion-collapse collapse"
        aria-labelledby="heading7"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH positions AS (
  SELECT * FROM uniswapv3.positions
),
    -- first get current positions:                         
max_blocks AS (
  SELECT
  min(block_id) AS min_block_id,
  max(block_id) AS max_block_id,
  pool_address,
  liquidity_provider,
  nf_token_id,
  date_trunc('day', block_timestamp) AS blk_date

  FROM positions
  
  GROUP BY
  pool_address,
  liquidity_provider,
  nf_token_id,
  blk_date
),
  max_blocks_prices AS (
  SELECT
  max(block_id) AS max_block_id,
  min(block_id) AS min_block_id,
  pool_address,
  date_trunc('day', block_timestamp) AS blk_date

  FROM uniswapv3.pool_stats
  
  GROUP BY
  pool_address,
  blk_date
),
current_positions_by_day AS (
  SELECT 
  p.pool_address,
  p.pool_name,
  p.nf_token_id,
  p.liquidity_provider,
  p.price_lower_1_0,
  p.price_upper_1_0,
  p.blk_date,
  case when p.block_id = mb.max_block_id then p.liquidity_adjusted else 0 end as max_liquidity_adjusted,
  case when p.block_id = mb_min.min_block_id then p.liquidity_adjusted else 0 end as min_liquidity_adjusted
    
  FROM (select *, date_trunc('day', block_timestamp) AS blk_date from positions) p
  left JOIN max_blocks mb ON 
  mb.blk_date = p.blk_date AND
  mb.max_block_id = p.block_id AND
  mb.pool_address = p.pool_address AND
  mb.liquidity_provider = p.liquidity_provider AND
  mb.nf_token_id = p.nf_token_id
  left JOIN max_blocks mb_min ON 
  mb_min.blk_date = p.blk_date AND
  mb_min.min_block_id = p.block_id AND
  mb_min.pool_address = p.pool_address AND
  mb_min.liquidity_provider = p.liquidity_provider AND
  mb_min.nf_token_id = p.nf_token_id
WHERE liquidity_adjusted > 0
  and (max_liquidity_adjusted > 0 or min_liquidity_adjusted > 0)
  -- and pool_name = 'USDC-WETH 3000 60'
), 
current_prices_by_day AS (
  SELECT 
  p.pool_address,
  p.pool_name,
  p.blk_date,
  case when p.block_id = mb.max_block_id then p.price_1_0 else 0 end as max_price_1_0,
  case when p.block_id = mb_min.min_block_id then p.price_1_0 else 0 end as min_price_1_0
    
  FROM (select *, date_trunc('day', block_timestamp) AS blk_date from uniswapv3.pool_stats) p
  left JOIN max_blocks_prices mb ON 
  mb.blk_date = p.blk_date AND
  mb.max_block_id = p.block_id AND
  mb.pool_address = p.pool_address
  left JOIN max_blocks_prices mb_min ON 
  mb_min.blk_date = p.blk_date AND
  mb_min.min_block_id = p.block_id AND
  mb_min.pool_address = p.pool_address
WHERE (max_price_1_0 > 0 or min_price_1_0 > 0)
  -- and pool_name = 'USDC-WETH 3000 60'
)
  
,  big5 as (
select tbl.*, row_number() over (order by tbl.tvl DESC) as rn
  from
(SELECT 
  pool_address, pool_name, --tick,
  --token0_symbol, token1_symbol,
  case when token0_symbol in ('USDC','USDT','DAI','FEI','EURS') and token1_symbol in ('USDC','USDT','DAI','FEI','EURS') then '_stable_stable_'
      when token0_symbol in ('USDC','USDT','DAI','FEI','EURS') or token1_symbol in ('USDC','USDT','DAI','FEI','EURS') then '_stable_other_'
      else '_other_other_' end as pairing_type,
    to_date(block_timestamp) as block_day
    ,avg(token0_balance_usd + token1_balance_usd) as tvl
    --,sum(virtual_reserves_token0_usd + virtual_reserves_token1_usd) as tvl_plus_fees
  --,tvl_plus_fees - tvl as fees_maybe
  ,avg(virtual_liquidity_adjusted) as virtual_liquidity_adjusted
  ,avg(virtual_reserves_token0_adjusted+virtual_reserves_token1_adjusted) as vitrul_reserves_split
  --,sum(protocol_fees_token0_adjusted+protocol_fees_token1_adjusted) as protocol_fees_adjusted
  --,sum(virtual_reserves_token0_usd/virtual_reserves_token0_adjusted*protocol_fees_token0_adjusted + 
  --virtual_reserves_token1_usd/virtual_reserves_token1_adjusted*protocol_fees_token1_adjusted)  as protocol_fees_adj_usd
  --,sum(fee_growth_global0_x128*pow(2,-128)) as fee_growth_global0
  --,sum(fee_growth_global1_x128*pow(2,-128)) as fee_growth_global1
FROM uniswapv3.pool_stats 
WHERE 
block_day = CURRENT_DATE() -1
  and pairing_type = '_stable_stable_'
  --block_id in (select max(block_id) as block_id from max_blocks)
  and (token0_balance_usd + token1_balance_usd) is not NULL
  --and pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' 
  --and (token0_symbol in ('DAI') or token1_symbol in ('DAI'))
group by 1,2,3,4
order by tvl DESC) tbl
  QUALIFY rn <= 5)

,response as (select pool.pool_name, pool.blk_date, pool.liquidity_provider--, pool.price_lower_1_0, pool.price_upper_1_0
  ,case when price_lower_1_0 <= max_price_1_0 and price_upper_1_0 >= max_price_1_0 then '_in_range_'
  else '_out_of_range_' end as current_liquidity_state_max
  ,case when price_lower_1_0 <= min_price_1_0 and price_upper_1_0 >= min_price_1_0 then '_in_range_'
  else '_out_of_range_' end as current_liquidity_state_min
, avg(pool.price_lower_1_0) as avg_price_lower_1_0, avg(pool.price_upper_1_0) as avg_price_upper_1_0
,avg(max_price_1_0) as max_price_1_0
,avg(min_price_1_0) as min_price_1_0
,sum(zeroifnull(pool.max_liquidity_adjusted)) as max_liquidity_adjusted
,sum(zeroifnull(pool.min_liquidity_adjusted)) as min_liquidity_adjusted
,sum(zeroifnull(inc_dec.token_increases)) as token_increases
,sum(zeroifnull(inc_dec.token_decrease)) as token_decrease
--,count(distinct pool.liquidity_provider) as num_active_lps
-- price_lower_1_0
  
FROM current_positions_by_day pool
inner join big5 F
on pool.pool_address = f.pool_address
left JOIN current_prices_by_day price
on pool.pool_address = price.pool_address
and pool.blk_date = price.blk_date
left join (select pool_address, date_trunc('day', block_timestamp) AS blk_date, liquidity_provider, nf_token_id
  , sum(case when action = 'INCREASE_LIQUIDITY' then 1 else 0 end) as token_increases
  , sum(case when action = 'DECREASE_LIQUIDITY' then 1 else 0 end) as token_decrease
  from uniswapv3.lp_actions group by 1,2,3,4) inc_dec
on pool.pool_address = inc_dec.pool_address
and pool.blk_date = inc_dec.blk_date
and pool.liquidity_provider = inc_dec.liquidity_provider
and pool.nf_token_id = inc_dec.nf_token_id
  -- where
group by 1,2,3,4,5)



, movement as (select blk_date, liquidity_provider, pool_name
  , current_liquidity_state_min
  , case when token_decrease > 0 and token_increases > 0 and current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_in_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Updated_range'
          when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_in_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Floated_into_range'
          when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_out_of_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Still_out_of_range'
      when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_out_of_range_' 
        and min_liquidity_adjusted > 0 and token_decrease > 0 then 'Reduced_exposure'
        else 'Other' end as change_that_day
  , sum(min_liquidity_adjusted) as min_liquidity_adjusted
  , sum(max_liquidity_adjusted) as max_liquidity_adjusted
  -- , case when token_decrease > 0 then 1 else 0 end as token_decrease_flg
  -- , case when token_increases > 0 then 1 else 0 end as token_increase_flg
  -- , current_liquidity_state_min, current_liquidity_state_max
  , avg(min_price_1_0) as min_price_1_0
  , avg(max_price_1_0) as max_price_1_0
  from  response
group by 1,2,3,4,5)


  , per_pool as (select a.blk_date, a.pool_name, a.change_that_day
,a.num_active_lps / b.num_active_lps as pct_num_active_lps
,a.min_liquidity_adjusted / b.min_liquidity_adjusted as pct_min_liquidity_adjusted
,a.max_liquidity_adjusted / b.max_liquidity_adjusted as pct_max_liquidity_adjusted
,a.min_price_1_0 as st_price_1_0
,a.max_price_1_0 as end_price_1_0
from
(select mv.blk_date, mv.pool_name, mv.change_that_day
  ,count(DISTINCT mv.liquidity_provider) as num_active_lps
  ,sum(mv.min_liquidity_adjusted) as min_liquidity_adjusted
  ,sum(mv.max_liquidity_adjusted) as max_liquidity_adjusted
  , avg(mv.min_price_1_0) as min_price_1_0
  , avg(mv.max_price_1_0) as max_price_1_0
  
  from movement as mv
where current_liquidity_state_min = '_out_of_range_'
group by 1,2,3) a
left join (select mv.blk_date, mv.pool_name
  ,count(DISTINCT mv.liquidity_provider) as num_active_lps
  ,sum(mv.min_liquidity_adjusted) as min_liquidity_adjusted
  ,sum(mv.max_liquidity_adjusted) as max_liquidity_adjusted
  
  from movement as mv
where current_liquidity_state_min = '_out_of_range_'
group by 1,2) b
on a.blk_date = b.blk_date
and a.pool_name = b.pool_name
  where b.num_active_lps > 0 and b.min_liquidity_adjusted > 0
  )


select a.blk_date, a.change_that_day
, a.pct_num_active_lps_avg / total_pct_num_active_lps_avg as pct_num_active_lps_avg
, a.pct_min_liquidity_adjusted_avg / total_pct_min_liquidity_adjusted_avg as pct_min_liquidity_adjusted_avg
from
(select blk_date, change_that_day
, avg(pct_num_active_lps) as pct_num_active_lps_avg
, avg(pct_min_liquidity_adjusted) as pct_min_liquidity_adjusted_avg
-- , avg(pct_max_liquidity_adjusted) as pct_max_liquidity_adjusted_avg
from per_pool
-- where pool_name = 'FEI-USDC 500 10'
group by 1,2) a
left join
(select blk_date
, sum(pct_num_active_lps_avg) as total_pct_num_active_lps_avg
, sum(pct_min_liquidity_adjusted_avg) as total_pct_min_liquidity_adjusted_avg
from
  (select blk_date, change_that_day
, avg(pct_num_active_lps) as pct_num_active_lps_avg
, avg(pct_min_liquidity_adjusted) as pct_min_liquidity_adjusted_avg
-- , avg(pct_max_liquidity_adjusted) as pct_max_liquidity_adjusted_avg
from per_pool
-- where pool_name = 'FEI-USDC 500 10'
group by 1,2)
group by 1) b
on a.blk_date = b.blk_date


--   ,sum(case when current_liquidity_state = '_in_range_' then sum_liquidity_adjusted else 0 end) as liquidity_adjusted_in_range
--   ,sum(case when current_liquidity_state = '_out_of_range_' then sum_liquidity_adjusted else 0 end) as liquidity_adjusted_out_of_range
--   ,sum(case when current_liquidity_state = '_in_range_' then num_active_lps else 0 end) as num_active_lps_in_range
--   ,sum(case when current_liquidity_state = '_out_of_range_' then num_active_lps else 0 end) as num_active_lps_out_of_range
--   ,sum(sum_liquidity_adjusted) as total_liquidity_adjusted
--   ,sum(num_active_lps) as total_num_active_lps
  
-- ,liquidity_adjusted_in_range/total_liquidity_adjusted as pct_liquidity_in_range
-- ,liquidity_adjusted_out_of_range/total_liquidity_adjusted as pct_liquidity_out_of_range
  
-- ,num_active_lps_in_range/total_num_active_lps as pct_active_lps_in_range
-- ,num_active_lps_out_of_range/total_num_active_lps as pct_active_lps_out_of_range
            
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading8">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse8"
          aria-expanded="false"
          aria-controls="collapse8"
        >
          Uniswap Stable Unstable pool activity *
        </button>
      </h2>
      <div
        id="collapse8"
        class="accordion-collapse collapse"
        aria-labelledby="heading8"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH positions AS (
  SELECT * FROM uniswapv3.positions
),
    -- first get current positions:                         
max_blocks AS (
  SELECT
  min(block_id) AS min_block_id,
  max(block_id) AS max_block_id,
  pool_address,
  liquidity_provider,
  nf_token_id,
  date_trunc('day', block_timestamp) AS blk_date

  FROM positions
  
  GROUP BY
  pool_address,
  liquidity_provider,
  nf_token_id,
  blk_date
),
  max_blocks_prices AS (
  SELECT
  max(block_id) AS max_block_id,
  min(block_id) AS min_block_id,
  pool_address,
  date_trunc('day', block_timestamp) AS blk_date

  FROM uniswapv3.pool_stats
  
  GROUP BY
  pool_address,
  blk_date
),
current_positions_by_day AS (
  SELECT 
  p.pool_address,
  p.pool_name,
  p.nf_token_id,
  p.liquidity_provider,
  p.price_lower_1_0,
  p.price_upper_1_0,
  p.blk_date,
  case when p.block_id = mb.max_block_id then p.liquidity_adjusted else 0 end as max_liquidity_adjusted,
  case when p.block_id = mb_min.min_block_id then p.liquidity_adjusted else 0 end as min_liquidity_adjusted
    
  FROM (select *, date_trunc('day', block_timestamp) AS blk_date from positions) p
  left JOIN max_blocks mb ON 
  mb.blk_date = p.blk_date AND
  mb.max_block_id = p.block_id AND
  mb.pool_address = p.pool_address AND
  mb.liquidity_provider = p.liquidity_provider AND
  mb.nf_token_id = p.nf_token_id
  left JOIN max_blocks mb_min ON 
  mb_min.blk_date = p.blk_date AND
  mb_min.min_block_id = p.block_id AND
  mb_min.pool_address = p.pool_address AND
  mb_min.liquidity_provider = p.liquidity_provider AND
  mb_min.nf_token_id = p.nf_token_id
WHERE liquidity_adjusted > 0
  and (max_liquidity_adjusted > 0 or min_liquidity_adjusted > 0)
  -- and pool_name = 'USDC-WETH 3000 60'
), 
current_prices_by_day AS (
  SELECT 
  p.pool_address,
  p.pool_name,
  p.blk_date,
  case when p.block_id = mb.max_block_id then p.price_1_0 else 0 end as max_price_1_0,
  case when p.block_id = mb_min.min_block_id then p.price_1_0 else 0 end as min_price_1_0
    
  FROM (select *, date_trunc('day', block_timestamp) AS blk_date from uniswapv3.pool_stats) p
  left JOIN max_blocks_prices mb ON 
  mb.blk_date = p.blk_date AND
  mb.max_block_id = p.block_id AND
  mb.pool_address = p.pool_address
  left JOIN max_blocks_prices mb_min ON 
  mb_min.blk_date = p.blk_date AND
  mb_min.min_block_id = p.block_id AND
  mb_min.pool_address = p.pool_address
WHERE (max_price_1_0 > 0 or min_price_1_0 > 0)
  -- and pool_name = 'USDC-WETH 3000 60'
)
  
,  big5 as (
select tbl.*, row_number() over (order by tbl.tvl DESC) as rn
  from
(SELECT 
  pool_address, pool_name, --tick,
  --token0_symbol, token1_symbol,
  case when token0_symbol in ('USDC','USDT','DAI','FEI','EURS') and token1_symbol in ('USDC','USDT','DAI','FEI','EURS') then '_stable_stable_'
      when token0_symbol in ('USDC','USDT','DAI','FEI','EURS') or token1_symbol in ('USDC','USDT','DAI','FEI','EURS') then '_stable_other_'
      else '_other_other_' end as pairing_type,
    to_date(block_timestamp) as block_day
    ,avg(token0_balance_usd + token1_balance_usd) as tvl
    --,sum(virtual_reserves_token0_usd + virtual_reserves_token1_usd) as tvl_plus_fees
  --,tvl_plus_fees - tvl as fees_maybe
  ,avg(virtual_liquidity_adjusted) as virtual_liquidity_adjusted
  ,avg(virtual_reserves_token0_adjusted+virtual_reserves_token1_adjusted) as vitrul_reserves_split
  --,sum(protocol_fees_token0_adjusted+protocol_fees_token1_adjusted) as protocol_fees_adjusted
  --,sum(virtual_reserves_token0_usd/virtual_reserves_token0_adjusted*protocol_fees_token0_adjusted + 
  --virtual_reserves_token1_usd/virtual_reserves_token1_adjusted*protocol_fees_token1_adjusted)  as protocol_fees_adj_usd
  --,sum(fee_growth_global0_x128*pow(2,-128)) as fee_growth_global0
  --,sum(fee_growth_global1_x128*pow(2,-128)) as fee_growth_global1
FROM uniswapv3.pool_stats 
WHERE 
block_day = CURRENT_DATE() -1 
  and pairing_type = '_stable_other_'
  --block_id in (select max(block_id) as block_id from max_blocks)
  and (token0_balance_usd + token1_balance_usd) is not NULL
  --and pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' 
  --and (token0_symbol in ('DAI') or token1_symbol in ('DAI'))
group by 1,2,3,4
order by tvl DESC) tbl
  QUALIFY rn <= 5)

,response as (select pool.pool_name, pool.blk_date, pool.liquidity_provider--, pool.price_lower_1_0, pool.price_upper_1_0
  ,case when price_lower_1_0 <= max_price_1_0 and price_upper_1_0 >= max_price_1_0 then '_in_range_'
  else '_out_of_range_' end as current_liquidity_state_max
  ,case when price_lower_1_0 <= min_price_1_0 and price_upper_1_0 >= min_price_1_0 then '_in_range_'
  else '_out_of_range_' end as current_liquidity_state_min
, avg(pool.price_lower_1_0) as avg_price_lower_1_0, avg(pool.price_upper_1_0) as avg_price_upper_1_0
,avg(max_price_1_0) as max_price_1_0
,avg(min_price_1_0) as min_price_1_0
,sum(zeroifnull(pool.max_liquidity_adjusted)) as max_liquidity_adjusted
,sum(zeroifnull(pool.min_liquidity_adjusted)) as min_liquidity_adjusted
,sum(zeroifnull(inc_dec.token_increases)) as token_increases
,sum(zeroifnull(inc_dec.token_decrease)) as token_decrease
--,count(distinct pool.liquidity_provider) as num_active_lps
-- price_lower_1_0
  
FROM current_positions_by_day pool
inner join big5 F
on pool.pool_address = f.pool_address
left JOIN current_prices_by_day price
on pool.pool_address = price.pool_address
and pool.blk_date = price.blk_date
left join (select pool_address, date_trunc('day', block_timestamp) AS blk_date, liquidity_provider, nf_token_id
  , sum(case when action = 'INCREASE_LIQUIDITY' then 1 else 0 end) as token_increases
  , sum(case when action = 'DECREASE_LIQUIDITY' then 1 else 0 end) as token_decrease
  from uniswapv3.lp_actions group by 1,2,3,4) inc_dec
on pool.pool_address = inc_dec.pool_address
and pool.blk_date = inc_dec.blk_date
and pool.liquidity_provider = inc_dec.liquidity_provider
and pool.nf_token_id = inc_dec.nf_token_id
  -- where
group by 1,2,3,4,5)



, movement as (select blk_date, liquidity_provider, pool_name
  , current_liquidity_state_min
  , case when token_decrease > 0 and token_increases > 0 and current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_in_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Updated_range'
          when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_in_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Floated_into_range'
          when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_out_of_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Still_out_of_range'
      when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_out_of_range_' 
        and min_liquidity_adjusted > 0 and token_decrease > 0 then 'Reduced_exposure'
        else 'Other' end as change_that_day
  , sum(min_liquidity_adjusted) as min_liquidity_adjusted
  , sum(max_liquidity_adjusted) as max_liquidity_adjusted
  -- , case when token_decrease > 0 then 1 else 0 end as token_decrease_flg
  -- , case when token_increases > 0 then 1 else 0 end as token_increase_flg
  -- , current_liquidity_state_min, current_liquidity_state_max
  , avg(min_price_1_0) as min_price_1_0
  , avg(max_price_1_0) as max_price_1_0
  from  response
group by 1,2,3,4,5)


  , per_pool as (select a.blk_date, a.pool_name, a.change_that_day
,a.num_active_lps / b.num_active_lps as pct_num_active_lps
,a.min_liquidity_adjusted / b.min_liquidity_adjusted as pct_min_liquidity_adjusted
-- ,a.max_liquidity_adjusted / b.max_liquidity_adjusted as pct_max_liquidity_adjusted
,a.min_price_1_0 as st_price_1_0
,a.max_price_1_0 as end_price_1_0
from
(select mv.blk_date, mv.pool_name, mv.change_that_day
  ,count(DISTINCT mv.liquidity_provider) as num_active_lps
  ,sum(mv.min_liquidity_adjusted) as min_liquidity_adjusted
  ,sum(mv.max_liquidity_adjusted) as max_liquidity_adjusted
  , avg(mv.min_price_1_0) as min_price_1_0
  , avg(mv.max_price_1_0) as max_price_1_0
  
  from movement as mv
where current_liquidity_state_min = '_out_of_range_'
group by 1,2,3) a
left join (select mv.blk_date, mv.pool_name
  ,count(DISTINCT mv.liquidity_provider) as num_active_lps
  ,sum(mv.min_liquidity_adjusted) as min_liquidity_adjusted
  ,sum(mv.max_liquidity_adjusted) as max_liquidity_adjusted
  
  from movement as mv
where current_liquidity_state_min = '_out_of_range_'
group by 1,2) b
on a.blk_date = b.blk_date
and a.pool_name = b.pool_name
  where b.num_active_lps > 0 and b.min_liquidity_adjusted > 0
  )


select a.blk_date, a.change_that_day
, a.pct_num_active_lps_avg / total_pct_num_active_lps_avg as pct_num_active_lps_avg
, a.pct_min_liquidity_adjusted_avg / total_pct_min_liquidity_adjusted_avg as pct_min_liquidity_adjusted_avg
from
(select blk_date, change_that_day
, avg(pct_num_active_lps) as pct_num_active_lps_avg
, avg(pct_min_liquidity_adjusted) as pct_min_liquidity_adjusted_avg
-- , avg(pct_max_liquidity_adjusted) as pct_max_liquidity_adjusted_avg
from per_pool
-- where pool_name = 'FEI-USDC 500 10'
group by 1,2) a
left join
(select blk_date
, sum(pct_num_active_lps_avg) as total_pct_num_active_lps_avg
, sum(pct_min_liquidity_adjusted_avg) as total_pct_min_liquidity_adjusted_avg
from
  (select blk_date, change_that_day
, avg(pct_num_active_lps) as pct_num_active_lps_avg
, avg(pct_min_liquidity_adjusted) as pct_min_liquidity_adjusted_avg
-- , avg(pct_max_liquidity_adjusted) as pct_max_liquidity_adjusted_avg
from per_pool
-- where pool_name = 'FEI-USDC 500 10'
group by 1,2)
group by 1) b
on a.blk_date = b.blk_date

-- select * from movement

--   ,sum(case when current_liquidity_state = '_in_range_' then sum_liquidity_adjusted else 0 end) as liquidity_adjusted_in_range
--   ,sum(case when current_liquidity_state = '_out_of_range_' then sum_liquidity_adjusted else 0 end) as liquidity_adjusted_out_of_range
--   ,sum(case when current_liquidity_state = '_in_range_' then num_active_lps else 0 end) as num_active_lps_in_range
--   ,sum(case when current_liquidity_state = '_out_of_range_' then num_active_lps else 0 end) as num_active_lps_out_of_range
--   ,sum(sum_liquidity_adjusted) as total_liquidity_adjusted
--   ,sum(num_active_lps) as total_num_active_lps
  
-- ,liquidity_adjusted_in_range/total_liquidity_adjusted as pct_liquidity_in_range
-- ,liquidity_adjusted_out_of_range/total_liquidity_adjusted as pct_liquidity_out_of_range
  
-- ,num_active_lps_in_range/total_num_active_lps as pct_active_lps_in_range
-- ,num_active_lps_out_of_range/total_num_active_lps as pct_active_lps_out_of_range
            
          </code></pre>
        </div>
      </div>
    </div>

    <div class="accordion-item">
      <h2 class="accordion-header" id="heading9">
        <button
          class="accordion-button collapsed"
          type="button"
          data-mdb-toggle="collapse"
          data-mdb-target="#collapse9"
          aria-expanded="false"
          aria-controls="collapse9"
        >
          Uniswap Unstable Unstable pool activity *
        </button>
      </h2>
      <div
        id="collapse9"
        class="accordion-collapse collapse"
        aria-labelledby="heading9"
        data-mdb-parent="#accordionExample"
      >
        <div class="accordion-body">
          <pre><code class="language-sql">
WITH positions AS (
  SELECT * FROM uniswapv3.positions
),
    -- first get current positions:                         
max_blocks AS (
  SELECT
  min(block_id) AS min_block_id,
  max(block_id) AS max_block_id,
  pool_address,
  liquidity_provider,
  nf_token_id,
  date_trunc('day', block_timestamp) AS blk_date

  FROM positions
  
  GROUP BY
  pool_address,
  liquidity_provider,
  nf_token_id,
  blk_date
),
  max_blocks_prices AS (
  SELECT
  max(block_id) AS max_block_id,
  min(block_id) AS min_block_id,
  pool_address,
  date_trunc('day', block_timestamp) AS blk_date

  FROM uniswapv3.pool_stats
  
  GROUP BY
  pool_address,
  blk_date
),
current_positions_by_day AS (
  SELECT 
  p.pool_address,
  p.pool_name,
  p.nf_token_id,
  p.liquidity_provider,
  p.price_lower_1_0,
  p.price_upper_1_0,
  p.blk_date,
  case when p.block_id = mb.max_block_id then p.liquidity_adjusted else 0 end as max_liquidity_adjusted,
  case when p.block_id = mb_min.min_block_id then p.liquidity_adjusted else 0 end as min_liquidity_adjusted
    
  FROM (select *, date_trunc('day', block_timestamp) AS blk_date from positions) p
  left JOIN max_blocks mb ON 
  mb.blk_date = p.blk_date AND
  mb.max_block_id = p.block_id AND
  mb.pool_address = p.pool_address AND
  mb.liquidity_provider = p.liquidity_provider AND
  mb.nf_token_id = p.nf_token_id
  left JOIN max_blocks mb_min ON 
  mb_min.blk_date = p.blk_date AND
  mb_min.min_block_id = p.block_id AND
  mb_min.pool_address = p.pool_address AND
  mb_min.liquidity_provider = p.liquidity_provider AND
  mb_min.nf_token_id = p.nf_token_id
WHERE liquidity_adjusted > 0
  and (max_liquidity_adjusted > 0 or min_liquidity_adjusted > 0)
  -- and pool_name = 'USDC-WETH 3000 60'
), 
current_prices_by_day AS (
  SELECT 
  p.pool_address,
  p.pool_name,
  p.blk_date,
  case when p.block_id = mb.max_block_id then p.price_1_0 else 0 end as max_price_1_0,
  case when p.block_id = mb_min.min_block_id then p.price_1_0 else 0 end as min_price_1_0
    
  FROM (select *, date_trunc('day', block_timestamp) AS blk_date from uniswapv3.pool_stats) p
  left JOIN max_blocks_prices mb ON 
  mb.blk_date = p.blk_date AND
  mb.max_block_id = p.block_id AND
  mb.pool_address = p.pool_address
  left JOIN max_blocks_prices mb_min ON 
  mb_min.blk_date = p.blk_date AND
  mb_min.min_block_id = p.block_id AND
  mb_min.pool_address = p.pool_address
WHERE (max_price_1_0 > 0 or min_price_1_0 > 0)
  -- and pool_name = 'USDC-WETH 3000 60'
)
  
,  big5 as (
select tbl.*, row_number() over (order by tbl.tvl DESC) as rn
  from
(SELECT 
  pool_address, pool_name, --tick,
  --token0_symbol, token1_symbol,
  case when token0_symbol in ('USDC','USDT','DAI','FEI','EURS') and token1_symbol in ('USDC','USDT','DAI','FEI','EURS') then '_stable_stable_'
      when token0_symbol in ('USDC','USDT','DAI','FEI','EURS') or token1_symbol in ('USDC','USDT','DAI','FEI','EURS') then '_stable_other_'
      else '_other_other_' end as pairing_type,
    to_date(block_timestamp) as block_day
    ,avg(token0_balance_usd + token1_balance_usd) as tvl
    --,sum(virtual_reserves_token0_usd + virtual_reserves_token1_usd) as tvl_plus_fees
  --,tvl_plus_fees - tvl as fees_maybe
  ,avg(virtual_liquidity_adjusted) as virtual_liquidity_adjusted
  ,avg(virtual_reserves_token0_adjusted+virtual_reserves_token1_adjusted) as vitrul_reserves_split
  --,sum(protocol_fees_token0_adjusted+protocol_fees_token1_adjusted) as protocol_fees_adjusted
  --,sum(virtual_reserves_token0_usd/virtual_reserves_token0_adjusted*protocol_fees_token0_adjusted + 
  --virtual_reserves_token1_usd/virtual_reserves_token1_adjusted*protocol_fees_token1_adjusted)  as protocol_fees_adj_usd
  --,sum(fee_growth_global0_x128*pow(2,-128)) as fee_growth_global0
  --,sum(fee_growth_global1_x128*pow(2,-128)) as fee_growth_global1
FROM uniswapv3.pool_stats 
WHERE 
block_day = CURRENT_DATE() -1 
  and pairing_type = '_other_other_'
  --block_id in (select max(block_id) as block_id from max_blocks)
  and (token0_balance_usd + token1_balance_usd) is not NULL
  --and pool_address = '0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8' 
  --and (token0_symbol in ('DAI') or token1_symbol in ('DAI'))
group by 1,2,3,4
order by tvl DESC) tbl
  QUALIFY rn <= 5)

,response as (select pool.pool_name, pool.blk_date, pool.liquidity_provider--, pool.price_lower_1_0, pool.price_upper_1_0
  ,case when price_lower_1_0 <= max_price_1_0 and price_upper_1_0 >= max_price_1_0 then '_in_range_'
  else '_out_of_range_' end as current_liquidity_state_max
  ,case when price_lower_1_0 <= min_price_1_0 and price_upper_1_0 >= min_price_1_0 then '_in_range_'
  else '_out_of_range_' end as current_liquidity_state_min
, avg(pool.price_lower_1_0) as avg_price_lower_1_0, avg(pool.price_upper_1_0) as avg_price_upper_1_0
,avg(max_price_1_0) as max_price_1_0
,avg(min_price_1_0) as min_price_1_0
,sum(zeroifnull(pool.max_liquidity_adjusted)) as max_liquidity_adjusted
,sum(zeroifnull(pool.min_liquidity_adjusted)) as min_liquidity_adjusted
,sum(zeroifnull(inc_dec.token_increases)) as token_increases
,sum(zeroifnull(inc_dec.token_decrease)) as token_decrease
--,count(distinct pool.liquidity_provider) as num_active_lps
-- price_lower_1_0
  
FROM current_positions_by_day pool
inner join big5 F
on pool.pool_address = f.pool_address
left JOIN current_prices_by_day price
on pool.pool_address = price.pool_address
and pool.blk_date = price.blk_date
left join (select pool_address, date_trunc('day', block_timestamp) AS blk_date, liquidity_provider, nf_token_id
  , sum(case when action = 'INCREASE_LIQUIDITY' then 1 else 0 end) as token_increases
  , sum(case when action = 'DECREASE_LIQUIDITY' then 1 else 0 end) as token_decrease
  from uniswapv3.lp_actions group by 1,2,3,4) inc_dec
on pool.pool_address = inc_dec.pool_address
and pool.blk_date = inc_dec.blk_date
and pool.liquidity_provider = inc_dec.liquidity_provider
and pool.nf_token_id = inc_dec.nf_token_id
  -- where
group by 1,2,3,4,5)



, movement as (select blk_date, liquidity_provider, pool_name
  , current_liquidity_state_min
  , case when token_decrease > 0 and token_increases > 0 and current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_in_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Updated_range'
          when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_in_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Floated_into_range'
          when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_out_of_range_' 
        and min_liquidity_adjusted > 0 and max_liquidity_adjusted > 0 then 'Still_out_of_range'
      when current_liquidity_state_min = '_out_of_range_' and current_liquidity_state_max = '_out_of_range_' 
        and min_liquidity_adjusted > 0 and token_decrease > 0 then 'Reduced_exposure'
        else 'Other' end as change_that_day
  , sum(min_liquidity_adjusted) as min_liquidity_adjusted
  , sum(max_liquidity_adjusted) as max_liquidity_adjusted
  -- , case when token_decrease > 0 then 1 else 0 end as token_decrease_flg
  -- , case when token_increases > 0 then 1 else 0 end as token_increase_flg
  -- , current_liquidity_state_min, current_liquidity_state_max
  , avg(min_price_1_0) as min_price_1_0
  , avg(max_price_1_0) as max_price_1_0
  from  response
group by 1,2,3,4,5)


  , per_pool as (select a.blk_date, a.pool_name, a.change_that_day
,a.num_active_lps / b.num_active_lps as pct_num_active_lps
,a.min_liquidity_adjusted / b.min_liquidity_adjusted as pct_min_liquidity_adjusted
-- ,a.max_liquidity_adjusted / b.max_liquidity_adjusted as pct_max_liquidity_adjusted
,a.min_price_1_0 as st_price_1_0
,a.max_price_1_0 as end_price_1_0
from
(select mv.blk_date, mv.pool_name, mv.change_that_day
  ,count(DISTINCT mv.liquidity_provider) as num_active_lps
  ,sum(mv.min_liquidity_adjusted) as min_liquidity_adjusted
  -- ,sum(mv.max_liquidity_adjusted) as max_liquidity_adjusted
  , avg(mv.min_price_1_0) as min_price_1_0
  , avg(mv.max_price_1_0) as max_price_1_0
  
  from movement as mv
where current_liquidity_state_min = '_out_of_range_'
group by 1,2,3) a
left join (select mv.blk_date, mv.pool_name
  ,count(DISTINCT mv.liquidity_provider) as num_active_lps
  ,sum(mv.min_liquidity_adjusted) as min_liquidity_adjusted
  -- ,sum(mv.max_liquidity_adjusted) as max_liquidity_adjusted
  
  from movement as mv
where current_liquidity_state_min = '_out_of_range_'
group by 1,2) b
on a.blk_date = b.blk_date
and a.pool_name = b.pool_name
  where b.num_active_lps > 0 and b.min_liquidity_adjusted > 0
  )


select a.blk_date, a.change_that_day
, a.pct_num_active_lps_avg / total_pct_num_active_lps_avg as pct_num_active_lps_avg
, a.pct_min_liquidity_adjusted_avg / total_pct_min_liquidity_adjusted_avg as pct_min_liquidity_adjusted_avg
from
(select blk_date, change_that_day
, avg(pct_num_active_lps) as pct_num_active_lps_avg
, avg(pct_min_liquidity_adjusted) as pct_min_liquidity_adjusted_avg
-- , avg(pct_max_liquidity_adjusted) as pct_max_liquidity_adjusted_avg
from per_pool
-- where pool_name = 'FEI-USDC 500 10'
group by 1,2) a
left join
(select blk_date
, sum(pct_num_active_lps_avg) as total_pct_num_active_lps_avg
, sum(pct_min_liquidity_adjusted_avg) as total_pct_min_liquidity_adjusted_avg
from
  (select blk_date, change_that_day
, avg(pct_num_active_lps) as pct_num_active_lps_avg
, avg(pct_min_liquidity_adjusted) as pct_min_liquidity_adjusted_avg
-- , avg(pct_max_liquidity_adjusted) as pct_max_liquidity_adjusted_avg
from per_pool
-- where pool_name = 'FEI-USDC 500 10'
group by 1,2)
group by 1) b
on a.blk_date = b.blk_date

--   ,sum(case when current_liquidity_state = '_in_range_' then sum_liquidity_adjusted else 0 end) as liquidity_adjusted_in_range
--   ,sum(case when current_liquidity_state = '_out_of_range_' then sum_liquidity_adjusted else 0 end) as liquidity_adjusted_out_of_range
--   ,sum(case when current_liquidity_state = '_in_range_' then num_active_lps else 0 end) as num_active_lps_in_range
--   ,sum(case when current_liquidity_state = '_out_of_range_' then num_active_lps else 0 end) as num_active_lps_out_of_range
--   ,sum(sum_liquidity_adjusted) as total_liquidity_adjusted
--   ,sum(num_active_lps) as total_num_active_lps
  
-- ,liquidity_adjusted_in_range/total_liquidity_adjusted as pct_liquidity_in_range
-- ,liquidity_adjusted_out_of_range/total_liquidity_adjusted as pct_liquidity_out_of_range
  
-- ,num_active_lps_in_range/total_num_active_lps as pct_active_lps_in_range
-- ,num_active_lps_out_of_range/total_num_active_lps as pct_active_lps_out_of_range
            
          </code></pre>
        </div>
      </div>
    </div>

  </div>


</section>

{% endblock %}